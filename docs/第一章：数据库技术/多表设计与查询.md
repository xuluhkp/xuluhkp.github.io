# 今日内容介绍

<extoc></extoc>

# 数据库设计

## 多表之间的关系

### 1. 一对多关系

    例如:

        一个部门下可以有多个员工，一个员工只能属于某一个部门。

        一个分类下有多个商品,一个商品只属于一个分类

        一个用户名下有多张银行卡,一个银行卡只属于一个用户

### 2. 多对多关系

    例如:

        一个学生可以选择多门课程，一门课程可以被多个学生选择。

        一个订单可以有多个商品,一个商品也可以属于多个订单

        一个用户可以使用多辆自行车,一个自行车也可以被多个用户使用

### 3. 一对一关系

    例如:

      一个公司可以有一个注册地址，一个注册地址只能对一个公司。

      一个人只能有一张身份证,一个身份证也只属于一个人

## 建表原则

### 一对多关系

    一个部门下可以有多个员工，一个员工只能属于某一个部门。

![](assets/markdown-img-paste-20180706173741458.png)

    **在多的一方创建外键指向一的一方的主键**


### 多对多关系

    一个学生选择多门课程，一门课程被多个学生所选择

![](assets/markdown-img-paste-20180706173801179.png)

    **需要创建中间表，中间表中至少两个字段，分别作为外键指向多对多双方的主键**

###  一对一关系

    一个公司可以对应一个注册地址，一个注册地址只能对应一个公司

![](assets/markdown-img-paste-20180706173815723.png)

    **唯一外键对应: 假设是一对多，在多的一方创建外键指向一的一方的主键，将外键设置为unique**

    **主键对应: 将两个表的主键建立对应关系即可**


## 数据库设计案例--旅游线路收藏
### 分析

    旅游线路收藏设计到三个数据实体:
    1. 旅游线路分类
    2. 旅游线路
    3. 用户

    分析三者之间的关系:

    1. `旅游线路分类` 和 `旅游线路` 是一对多的关系 , 一个分类下会有多个线路,一个线路只属于一个分类
    2. `旅游线路` 和 `用户` 是多对多的关系 , 一个线路可以被多个用户收藏,一个用户也可以收藏多个线路

### 实现
```sql
-- 创建旅游线路分类表 tab_category
-- cid 旅游线路分类主键，自动增长
-- cname 旅游线路分类名称非空，唯一，字符串 100
CREATE TABLE tab_category (
  cid INT PRIMARY KEY AUTO_INCREMENT,
  cname VARCHAR(100) NOT NULL UNIQUE
);

-- 创建旅游线路表 tab_route
/*
rid 旅游线路主键，自动增长
rname 旅游线路名称非空，唯一，字符串 100
price 价格
rdate 上架时间，日期类型
cid 外键，所属分类
*/
CREATE TABLE tab_route(
  rid INT PRIMARY KEY AUTO_INCREMENT,
  rname VARCHAR(100) NOT NULL UNIQUE,
  price DOUBLE,
  rdate DATE,
  cid INT,
  FOREIGN KEY (cid) REFERENCES tab_category(cid)
);

/*创建用户表 tab_user
uid 用户主键，自增长
username 用户名长度 100，唯一，非空
password 密码长度 30，非空
name 真实姓名长度 100
birthday 生日
sex 性别，定长字符串 1
telephone 手机号，字符串 11
email 邮箱，字符串长度 100
*/
CREATE TABLE tab_user (
  uid INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(100) UNIQUE NOT NULL,
  PASSWORD VARCHAR(30) NOT NULL,
  NAME VARCHAR(100),
  birthday DATE,
  sex CHAR(1) DEFAULT '男',
  telephone VARCHAR(11),
  email VARCHAR(100)
);

/*
创建收藏表 tab_favorite
rid 旅游线路 id，外键
date 收藏时间
uid 用户 id，外键
rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次
*/
CREATE TABLE tab_favorite (
  rid INT, -- 线路id
  DATE DATETIME,
  uid INT, -- 用户id
  -- 创建复合主键
  PRIMARY KEY(rid,uid), -- 联合主键
  FOREIGN KEY (rid) REFERENCES tab_route(rid),
  FOREIGN KEY(uid) REFERENCES tab_user(uid)
);
```

#### 关系模型图

![](assets/markdown-img-paste-20180706175404947.png)


### 数据库设计的范式(了解)

#### 概念：
    设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求

  	设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
  	目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

#### 分类
    1. 第一范式（1NF）：每一列都是不可分割的原子数据项

    2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）

        1. 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
          例如：学号-->姓名。  （学号，课程名称） --> 分数
        2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
          例如：（学号，课程名称） --> 分数
        3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
          例如：（学号，课程名称） -- > 姓名
        4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
          例如：学号-->系名，系名-->系主任
        5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
          例如：该表中码为：（学号，课程名称）
          * 主属性：码属性组中的所有属性
          * 非主属性：除过码属性组的属性


    3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）


# 数据库的备份和还原

## 数据库备份

步骤一: 打开cmd的命令行窗口,执行命令

```
mysqldump -u root -p web_test1 >C:/web_test1.sql
```

![](assets/markdown-img-paste-2018070618063470.png)

箭头后面的就是备份文件的全路径

## 数据库还原

**第一种还原方式**

步骤一: 在数据库服务器内部创建数据库

![](assets/markdown-img-paste-20180706180646681.png)

步骤二: 在命令行窗口执行还原命令
```
mysql -u root -p web_test1 < C:/web_test1.sql
```
![](assets/markdown-img-paste-20180706180657287.png)

**第二种还原方式**

步骤一: 在数据库服务器内部创建数据库

![](assets/markdown-img-paste-20180706180707406.png)

步骤二: 登录数据库,切换到该数据库,在mysql命令行窗口执行source命令还原

![](assets/markdown-img-paste-20180706180718400.png)

## 可视化界面完成备份和还原

**备份**

![](assets/markdown-img-paste-20180706180824629.png)

![](assets/markdown-img-paste-20180706180906599.png)

**还原**

![](assets/markdown-img-paste-20180706181011713.png)

![](assets/markdown-img-paste-20180706181038757.png)


# 多表查询

## 查询语法
```sql
select
  列名列表
from
  表名列表
where  条件
```

## 数据准备
```sql
-- 创建部门表
CREATE TABLE dept(
  id INT PRIMARY KEY AUTO_INCREMENT,
  NAME VARCHAR(20)
);
INSERT INTO dept (NAME) VALUES ('开发部'),('市场部'),('财务部'),('销售部');

-- 创建员工表
CREATE TABLE emp (
  id INT PRIMARY KEY AUTO_INCREMENT,
  NAME VARCHAR(10),
  gender CHAR(1), -- 性别
  salary DOUBLE, -- 工资
  join_date DATE, -- 入职日期
  dept_id INT,
  FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)
);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('孙悟空','男',7200,'2013-02-24',1);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('猪八戒','男',3600,'2010-12-02',2);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('唐僧','男',9000,'2008-08-08',2);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('白骨精','女',5000,'2015-10-07',3);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('蜘蛛精','女',4500,'2011-03-14',1);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('李世民','男',10000,'1820-09-11',NULL);
```

## 多表查询分类

    1. 内连接  `INNER`  可以省略
      * 显示内连接: `SELECT * FROM 表1 INNER JOIN 表2 ON 连接条件`
      * 隐式内连接: `SELECT * FROM 表1 , 表2 WHERE 连接条件`
    2. 外连接 : `OUTER` 可以省略
      * 左外连接: `SELECT * FROM 表1 LEFT OUTER JOIN 表2 ON 连接条件`
      * 右外连接: `SELECT * FROM 表1 RIGHT OUTER JOIN 表2 ON 连接条件`
    3. 子查询 :其实就是SQL的嵌套
      * 单行子查询: 子句的查询结果只有一行  `SELECT * FROM 表1 WHERE 字段名称 = (子查询语句)`
      * 多行子查询: 子句的查询结果有多行  `SELECT * FROM 表1 WHERE 字段名称 in (子查询语句)`

### 内连接

```sql
1. 隐式内连接：使用where条件消除无用数据
-- 查询所有员工信息和对应的部门信息
SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

-- 查询员工表的名称，性别。部门表的名称
SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

-- 使用别名进行查询
SELECT
  t1.name, -- 员工表的姓名
  t1.gender,-- 员工表的性别
  t2.name -- 部门表的名称
FROM
  emp t1,
  dept t2
WHERE
  t1.`dept_id` = t2.`id`;


2. 显式内连接：

* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
* 例如：
  -- 查询所有的部门及员工信息
  SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;
  SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;
```

    注意:使用内连接查询,要先分析清除以下的三个方面：
    1. 从哪些表中查询数据
    2. 条件是什么
    3. 查询哪些字段


### 外连接
```sql
1. 左外连接：
  * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；
  * 查询的是左表所有数据以及其交集部分。
  * 例子：
    -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
    SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;


2. 右外连接：
  * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；
  * 查询的是右表所有数据以及其交集部分。
  * 例子：
    -- 查询所有的部门及员工信息,没有员工的部门也要展示
    SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;
```

内连接和左外连接右外连接的结果集的区别

![](assets/markdown-img-paste-20180708192933865.png)

### 子查询

子查询 ：查询中嵌套查询，称嵌套查询为子查询。

```sql
-- 查询工资最高的员工信息
-- 1 查询最高的工资是多少 9000
SELECT MAX(salary) FROM emp;

-- 2 查询员工信息，并且工资等于9000的
SELECT * FROM emp WHERE emp.`salary` = 9000;

-- 一条sql就完成这个操作。子查询
SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);
```

1. 单行单列子查询:子查询的结果是单行单列的：

```SQL
* 子查询可以作为条件，使用运算符去判断。 运算符： > >= < <= =
-- 查询员工工资小于平均工资的人
SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp);

```

2. 多行单列子查询:子查询的结果是多行单列的：
```sql
-- 子查询可以作为条件，使用运算符in来判断
-- 查询'财务部'和'市场部'所有的员工信息
SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';
SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
-- 子查询
SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');
```

3. 多行多列子查询:子查询的结果是多行多列的

```sql
-- 子查询可以作为一张虚拟表参与查询
-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
-- 子查询
SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2 WHERE t1.id = t2.dept_id;

-- 普通内连接
SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  '2011-11-11'
```



## 多表查询练习
### 准备
```sql
-- 部门表
CREATE TABLE dept (
  id INT PRIMARY KEY PRIMARY KEY, -- 部门id
  dname VARCHAR(50), -- 部门名称
  loc VARCHAR(50) -- 部门所在地
);

-- 添加4个部门
INSERT INTO dept(id,dname,loc) VALUES
(10,'教研部','北京'),
(20,'学工部','上海'),
(30,'销售部','广州'),
(40,'财务部','深圳');


-- 职务表，职务名称，职务描述
CREATE TABLE job (
  id INT PRIMARY KEY,
  jname VARCHAR(20),
  description VARCHAR(50)
);

-- 添加4个职务
INSERT INTO job (id, jname, description) VALUES
(1, '董事长', '管理整个公司，接单'),
(2, '经理', '管理部门员工'),
(3, '销售员', '向客人推销产品'),
(4, '文员', '使用办公软件');

-- 员工表
CREATE TABLE emp (
  id INT PRIMARY KEY, -- 员工id
  ename VARCHAR(50), -- 员工姓名
  job_id INT, -- 职务id
  mgr INT , -- 上级领导
  joindate DATE, -- 入职日期
  salary DECIMAL(7,2), -- 工资
  bonus DECIMAL(7,2), -- 奖金
  dept_id INT, -- 所在部门编号
  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 添加员工
INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES
(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);

-- 工资等级表
CREATE TABLE salarygrade (
  grade INT PRIMARY KEY,   -- 级别
  losalary INT,  -- 最低工资
  hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000),(4,20010,30000),(5,30010,99990);
```

### 需求
1. 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
```sql
/*
	分析：
		1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表
		2.查询条件 emp.job_id = job.id
*/
SELECT
	t1.`id`, -- 员工编号
	t1.`ename`, -- 员工姓名
	t1.`salary`,-- 工资
	t2.`jname`, -- 职务名称
	t2.`description` -- 职务描述
FROM
	emp t1, job t2
WHERE
	t1.`job_id` = t2.`id`;
```

2. 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
```sql
/*
	分析：
		1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept
		2. 条件： emp.job_id = job.id and emp.dept_id = dept.id
*/
SELECT
	t1.`id`, -- 员工编号
	t1.`ename`, -- 员工姓名
	t1.`salary`,-- 工资
	t2.`jname`, -- 职务名称
	t2.`description`, -- 职务描述
	t3.`dname`, -- 部门名称
	t3.`loc` -- 部门位置
FROM
	emp t1, job t2,dept t3
WHERE
	t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;
```

3. 查询员工姓名，工资，工资等级
```sql
/*
	分析：
		1.员工姓名，工资 emp  工资等级 salarygrade
		2.条件 emp.salary >= salarygrade.losalary and emp.salary <= salarygrade.hisalary
			emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
*/
SELECT
	t1.ename ,
	t1.`salary`,
	t2.*
FROM emp t1, salarygrade t2
WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
```

4. 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
```sql
/*
	分析：
		1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade
		2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
*/
SELECT
	t1.`ename`,
	t1.`salary`,
	t2.`jname`,
	t2.`description`,
	t3.`dname`,
	t3.`loc`,
	t4.`grade`
FROM
	emp t1,job t2,dept t3,salarygrade t4
WHERE
	t1.`job_id` = t2.`id`
	AND t1.`dept_id` = t3.`id`
	AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;
```

5. 查询出部门编号、部门名称、部门位置、部门人数
```sql
/*
	分析：
		1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表
		2.使用分组查询。按照emp.dept_id完成分组，查询count(id)
		3.使用子查询将第2步的查询结果和dept表进行关联查询
*/
SELECT
	t1.`id`,t1.`dname`,t1.`loc` , t2.total
FROM
	dept t1,
	(SELECT
		dept_id,COUNT(id) total
	FROM
		emp
	GROUP BY dept_id) t2
WHERE t1.`id` = t2.dept_id;
```

6. 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
```sql
/*
	分析：
		1.姓名 emp， 直接上级的姓名 emp
			* emp表的id 和 mgr 是自关联
		2.条件 emp.id = emp.mgr
		3.查询左表的所有数据，和 交集数据
			* 使用左外连接查询
*/
-- 员工的姓名及其直接上级的姓名,领导的员工不查询
select
	t1.ename,
	t1.mgr,
	t2.`id`,
	t2.ename
from emp t1, emp t2
where t1.mgr = t2.`id`;
-- 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
SELECT
	t1.ename,
	t1.mgr,
	t2.`id`,
	t2.`ename`
FROM emp t1
LEFT JOIN emp t2
ON t1.`mgr` = t2.`id`;
```

# 作业

## 作业一:理解并完成课堂案例
## 作业二:多表设计练习

多表设计练习:完成一个简单商城系统的数据库设计,该商城系统包含以下实体,一些基本字段及类型已经提供,试分析各个实体之间的关系,完成数据库表的创建

**用户表   user**

| 字段名		|	字段类型	|	长度			|	约束   |
| :------------- | :------------- |:------------- | :------------- |
| uid			|	整形		|	11				|	主键   |
| uname		|	字符串		|	20				|	非空       |
| pwd     	|	字符串		|	10		        |              |
| email		|	字符串		|	10		        |	唯一       |

**商品表 product**

| 字段名		|	字段类型	|	长度			|	约束  |
| :------------- | :------------- |:------------- | :------------- |
| pid			|	整形		|	11				|	主键  |
| pname		|	字符串		|	20				|	非空      |
| intro     	|	字符串		|	10		        |         |
| price		|	浮点型		|	(10,2	)	    |     非空        |


**订单表  orders**

| 字段名		|	字段类型	|	长度			|	约束   |
| :------------- | :------------- |:------------- | :------------- |
| oid			|	整形		|	11				|	主键   |
| orderno		|	字符串		|	20				|	非空   |
| ordertime   |	日期		|			        |              |
| totalprice	|	浮点型		| (	10,2)		    |   非空     |

**订单详情表 order_detail**

| 字段名		|	字段类型	|	长度			|	约束   |
| :------------- | :------------- |:------------- | :------------- |
| did			|	整形		|	11				|	主键   |
| oid		|	整形		|	11				|	非空   |
| pid   |	整形		|	11		        |      	非空         |
| num   | 整形  |  11 | 	非空
| price	|	浮点型		|	(10,2)		    |   	非空        |


**分类表  category**

| 字段名		|	字段类型	|	长度			|	约束  |
| :------------- | :------------- |:------------- | :------------- |
| cid			|	整形		|	11				|	主键  |
| cname		|	字符串		|	20				|	非空      |


## 作业三:图书管理系统

**学生信息表：student**

|  字段名称  |  数据类型  |  说明           |  
| :------------- | :------------- |:------------- |
|  stuID  |  char(10)  |  学生编号，主键    |  
|  stuName  |  Varchar(10)  |  学生名称     |  
|  major  |  Varchar(50)  |  专业           |  


**图书表：book**

|字段名称  |  数据类型  |  说明       |
| :------------- | :------------- |:------------- |
|BID  |  char(10)  |  图书编号，主键  |
|title  |  char(50)  |  书名          |
|author  |  char(20)  |  作者         |


**借书信息表：borrow**

| 字段名称  |  数据类型  |  说明           |
| :------------- | :------------- |:------------- |
| borrowID  |  char(10)  |  借书编号，主键 |
| stuID  |  char(10)  |  学生编号，外键    |
| BID  |  char(10)  |  图书编号，外键      |
| time  |  datetime  |  借书日期         |
| B_time  |  datetime  |  还书日期         |


创建表插入如下数据:

```sql
-- 创建图书表
CREATE TABLE  book (
  BID CHAR(10) NOT NULL,
  title CHAR(50) DEFAULT NULL,
  author CHAR(20) DEFAULT NULL,
  PRIMARY KEY (BID)
);

INSERT INTO book VALUES ('B001', '人生若只如初见', '安意如');
INSERT INTO book VALUES ('B002', '入学那天遇见你', '晴空');
INSERT INTO book VALUES ('B003', '感谢折磨你的人', '如娜');
INSERT INTO book VALUES ('B004', '我不是教你诈', '刘庸');
INSERT INTO book VALUES ('B005', '英语四级', '白雪');

-- 创建借书表
CREATE TABLE  borrow (
  borrowID CHAR(10) NOT NULL,
  stuID CHAR(10) DEFAULT NULL,
  BID CHAR(10) DEFAULT NULL,
  T_time VARCHAR(50) DEFAULT NULL,
  B_time VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (borrowID)
) ;

INSERT INTO borrow VALUES ('T001', '1001', 'B001', '2007-12-26 00:00:00', NULL);
INSERT INTO borrow VALUES ('T002', '1004', 'B003', '2008-01-05 00:00:00', NULL);
INSERT INTO borrow VALUES ('T003', '1005', 'B001', '2007-10-08 00:00:00', '2007-12-25 00:00:00');
INSERT INTO borrow VALUES ('T004', '1005', 'B002', '2007-12-16 00:00:00', '2008-01-07 00:00:00');
INSERT INTO borrow VALUES ('T005', '1002', 'B004', '2007-12-22 00:00:00', NULL);
INSERT INTO borrow VALUES ('T006', '1005', 'B005', '2008-01-06 00:00:00', NULL);
INSERT INTO borrow VALUES ('T007', '1002', 'B001', '2007-09-11 00:00:00', NULL);
INSERT INTO borrow VALUES ('T008', '1005', 'B004', '2007-12-10 00:00:00', NULL);
INSERT INTO borrow VALUES ('T009', '1004', 'B005', '2007-10-16 00:00:00', '2007-12-18 00:00:00');
INSERT INTO borrow VALUES ('T010', '1002', 'B002', '2007-09-15 00:00:00', '2008-01-05 00:00:00');
INSERT INTO borrow VALUES ('T011', '1004', 'B003', '2007-12-28 00:00:00', NULL);
INSERT INTO borrow VALUES ('T012', '1002', 'B003', '2007-12-30 00:00:00', NULL);

-- 创建学生表
CREATE TABLE  student (
  stuID CHAR(10) NOT NULL,
  stuName VARCHAR(10) DEFAULT NULL,
  major VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (stuID)
) ;

INSERT INTO student VALUES ('1001', '林林', '计算机');
INSERT INTO student VALUES ('1002', '白杨', '计算机');
INSERT INTO student VALUES ('1003', '虎子', '英语');
INSERT INTO student VALUES ('1004', '北漂的雪', '工商管理');
INSERT INTO student VALUES ('1005', '五月', '数学');

```

**按要求查询下列结果**

1. 查询“计算机”专业学生在“2007-12-15”至“2008-1-8”时间段内借书的学生编号、学生名称、图书编号、图书名称、借出日期；
```sql
SELECT s.stuID 学生编号 ,s.stuName 学生名称 ,bk.BID 图书编号 ,bk.title 图书名称 ,b.t_time 借出日期  FROM  student s INNER JOIN  borrow b ON s.stuID = b.stuID INNER JOIN  book bk ON bk.BID = b.BID  WHERE s.major  = '计算机' AND b.t_time BETWEEN '2007-12-15' AND '2008-1-8'  
```

2. 查询所有借过图书的学生编号、学生名称、专业；
```sql
SELECT DISTINCT s.stuID 学生编号  ,s.stuName 学生名称 ,s.major 专业  FROM  student s INNER JOIN  borrow b ON s.stuID = b.stuID   
```

3. 查询没有借过图书的学生编号、学生名称、专业；
```sql
SELECT  DISTINCT s.stuID 学生编号  ,s.stuName 学生名称 ,s.major 专业  FROM  student s LEFT OUTER JOIN  borrow b ON s.stuID = b.stuID  WHERE b.borrowID IS NULL  
```

4. 查询借过作者为“安意如”的图书的学生姓名、图书名称、借出日期、归还日期；
```sql
SELECT s.stuName 学生名称,bk.title 图书名称,b.t_time 借出日期 ,b.B_time 归还日期 FROM  student s INNER JOIN  borrow b ON s.stuID = b.stuID INNER  JOIN  book bk ON bk.BID = b.BID  WHERE bk.author = '安意如'  
```

5. 查询借过书但有书未归还的学生编号、学生名称、图书编号、图书名称、借出日期
```sql
SELECT s.stuID 学生编号  ,s.stuName 学生名称,bk.title 图书名称,b.t_time 借出日期  FROM  student s INNER JOIN  borrow b ON s.stuID = b.stuID INNER JOIN  book bk ON bk.BID=b.BID WHERE b.B_time IS NULL   
```

6. 查询目前借书但未归还图书的学生名称及未还图书数量；
```sql
SELECT s.stuName 学生名称,COUNT(1) 未还图书数量 FROM  student s INNER JOIN  borrow b ON s.stuID = b.stuID WHERE b.B_time IS NULL  GROUP BY s.stuName ,s.stuID  
```

##作业四:入学分班系统
**学生表 student**

| 字段名称  |  数据类型  |  说明          |
| :------------- | :------------- |:------------- |
| sid  |  varchar(10)  |  学号,主键       |
| sname  |  varchar(10)  |  学生姓名      |
| sage  |  int  |  年龄              |
| cid  |  varchar(10)  |  所属班级id      |

**班级表 class**

| 字段名称  |  数据类型  |  说明             |
| :------------- | :------------- |:------------- |
| cid  |  varchar(10)  |  班号 ,主键         |
| major  |  varchar(10)  |  专业名           |
| did  |  varchar(10)  |  所属系的id         |
| entrydate  |  date  |  入学年份            |

**系  department**

| 字段名称  |  数据类型  |  说明           |
| :------------- | :------------- |:------------- |
| did  |  varchar(10)  |  系号 主键        |
| dname  |  varchar(10)  |  系名           |


创建表,插入如下数据

```sql

CREATE TABLE class (
  cid VARCHAR(10) NOT NULL,
  major VARCHAR(10) DEFAULT NULL,
  did VARCHAR(10) DEFAULT NULL,
  entrydate VARCHAR(4) DEFAULT NULL,
  PRIMARY KEY (cid)
) ;


INSERT INTO class VALUES ('101', '软件', '002', '1995');
INSERT INTO class VALUES ('102', '微电子', '002', '1996');
INSERT INTO class VALUES ('111', '无机化学', '003', '1995');
INSERT INTO class VALUES ('112', '高分子化学', '003', '1996');
INSERT INTO class VALUES ('121', '统计数学', '001', '1995');
INSERT INTO class VALUES ('131', '现代语言', '004', '1996');
INSERT INTO class VALUES ('141', '国际贸易', '005', '1997');
INSERT INTO class VALUES ('142', '国际金融', '005', '1996');
INSERT INTO class VALUES ('143', '电子商务', '005', '1998');


CREATE TABLE department (
  did VARCHAR(10) NOT NULL,
  dname VARCHAR(10) DEFAULT NULL,
  PRIMARY KEY (did)
) ;


INSERT INTO department VALUES ('001', '数学');
INSERT INTO department VALUES ('002', '计算机');
INSERT INTO department VALUES ('003', '化学');
INSERT INTO department VALUES ('004', '中文');
INSERT INTO department VALUES ('005', '经济');
INSERT INTO department VALUES ('006', '物理系');


CREATE TABLE student (
  sid VARCHAR(10) NOT NULL,
  sname VARCHAR(10) NOT NULL,
  sage INT(6) DEFAULT NULL,
  cid VARCHAR(10) DEFAULT NULL,
  PRIMARY KEY (sid)
) ;


INSERT INTO student VALUES ('8101', '张三', '18', '101');
INSERT INTO student VALUES ('8102', '钱四', '16', '121');
INSERT INTO student VALUES ('8103', '王玲', '17', '131');
INSERT INTO student VALUES ('8105', '李飞', '19', '102');
INSERT INTO student VALUES ('8109', '赵四', '18', '141');
INSERT INTO student VALUES ('8110', '李可', '20', '142');
INSERT INTO student VALUES ('8201', '张飞', '18', '111');
INSERT INTO student VALUES ('8203', '王亮', '17', '111');
INSERT INTO student VALUES ('8302', '周瑜', '16', '112');
INSERT INTO student VALUES ('8305', '董庆', '19', '102');
INSERT INTO student VALUES ('8409', '赵龙', '18', '101');
INSERT INTO student VALUES ('8510', '李丽', '20', '142');
```

**查询如下结果**

1. 找出所有姓李的学生，并按其年龄由小到大排序。
```sql
SELECT * FROM student WHERE sname LIKE '李%' ORDER BY sage ASC
```

2. 列出所有开设超过两个班级的系的信息
```sql
select * from Department where did in ( SELECT d.did FROM class c INNER JOIN department d ON c.did = d.did GROUP BY d.did HAVING COUNT(1)>2 );
```

3. 列出所有开设超过两个专业的系的信息。 注意不同的班级相同的专业相同的系应该去掉
```sql
select * from department d where d.did in ( select did from ( SELECT did FROM class  GROUP BY major ,did ) t group by did HAVING COUNT(1)>2 );
```

4. 列出所有班级的人数及对应的系的信息
```sql
select d.*,t.c 班级的人数 from department d inner join ( select c.cid,c.did,count(1) c from class c inner join student s on c.cid = s.cid GROUP BY c.cid ,c.did ) t on d.did = t.did
```

5. 列出有班级人数大于等于2的系的编号的名称
```sql
select d.*,t.c 班级的人数 from department d inner join ( select c.cid,c.did,count(1) c from class c inner join student s on c.cid = s.cid GROUP BY c.cid ,c.did having count(1)>=2 ) t on d.did = t.did
```

6. 列出有班级人数小于2的系的编号的名称   包括没有开班的
```sql
select d.*,t.c 班级的人数 from department d inner join ( select c.cid,d.did,count(1) c from class c inner join student s on c.cid = s.cid right join department d on d.did = c.did GROUP BY c.cid ,d.did having count(1)<2 ) t on d.did = t.did
```

7. 列出每个班学生人数都大于等于2的系的编号和名称。      有班级人数小于二的系找到  
```sql
SELECT * FROM department dp WHERE dp.did NOT IN (
select d.did from department d inner join ( select c.cid,d.did,count(1) c from class c inner join student s on c.cid = s.cid right join department d on d.did = c.did GROUP BY c.cid ,d.did having count(1)<2 ) t on d.did = t.did
);
-- 或者
SELECT dp.* FROM department dp  LEFT OUTER JOIN   (select d.*,t.c 班级的人数 from department d inner join ( select c.cid,d.did,count(1) c from class c inner join student s on c.cid = s.cid right join department d on d.did = c.did GROUP BY c.cid ,d.did having count(1)<2 ) t on d.did = t.did
 ) t ON dp.did = t.did WHERE t.did IS NULL
```
